<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>君青诵</title>
  <subtitle>高山流水曲和寡，天涯何处识琴心</subtitle>
  <link href="/MyBlog/atom.xml" rel="self"/>
  
  <link href="https://jqs1970291214.github.io/MyBlog/"/>
  <updated>2017-10-27T02:48:07.214Z</updated>
  <id>https://jqs1970291214.github.io/MyBlog/</id>
  
  <author>
    <name>JQS</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【笔记】斜杠(forward salash)与反斜杠(back salash)在路径应用中的区别</title>
    <link href="https://jqs1970291214.github.io/MyBlog/2017/10/27/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91%E6%96%9C%E6%9D%A0-forward-salash-%E4%B8%8E%E5%8F%8D%E6%96%9C%E6%9D%A0-back-salash-%E5%9C%A8%E8%B7%AF%E5%BE%84%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://jqs1970291214.github.io/MyBlog/2017/10/27/【笔记】斜杠-forward-salash-与反斜杠-back-salash-在路径应用中的区别/</id>
    <published>2017-10-27T02:46:18.000Z</published>
    <updated>2017-10-27T02:48:07.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【笔记】斜杠-forward-salash-与反斜杠-back-salash-在路径应用中的区别"><a href="#【笔记】斜杠-forward-salash-与反斜杠-back-salash-在路径应用中的区别" class="headerlink" title="【笔记】斜杠(forward salash)与反斜杠(back salash)在路径应用中的区别"></a>【笔记】斜杠(forward salash)与反斜杠(back salash)在路径应用中的区别</h1><h3 id="一、各系统下的文件路径"><a href="#一、各系统下的文件路径" class="headerlink" title="一、各系统下的文件路径"></a><p color="red">一、各系统下的文件路径</p></h3><ol>
<li><p>unix系统中使用斜杠（/）作为路径分隔符。</p>
</li>
<li><p>Windows早期使用斜杠（/）<br>作为DOS命令提示符的参数标志。  为了防止混淆，采用反斜杠（\） 作为路径分隔符。<br>所以目前windows系统上的文件浏览器都是用 反斜杠（\） 作为路径分隔符。随着发展，DOS系统已经被淘汰了，命令提示符也用的很少，斜杆和反斜杠在大多数情况下可以互换，没有影响。Windows文件资源管理器地址栏认为斜杠和反斜杠是等效的。</p>
<h3 id="二、C语言中的文件路径字符串"><a href="#二、C语言中的文件路径字符串" class="headerlink" title="二、C语言中的文件路径字符串"></a><p color="red">二、C语言中的文件路径字符串</p></h3></li>
</ol>
<p>在Windows下的C（C++）语言中，由于Windows路径使用反斜杠\，但“\”同时是转义序列的引导，所以要写成“\”，比如文件路径字符串”C:\Users\Administrator\Destop\filename.file”。而在Unix，Linux和其他类Unix系统中，使用斜杠（/)。</p>
<h3 id="三、网络领域的的应用"><a href="#三、网络领域的的应用" class="headerlink" title="三、网络领域的的应用"></a><p color="red">三、网络领域的的应用</p></h3><p>1.由于早期web应用受Unix的影响。浏览器地址栏的网址，URL统一资源定位符使用斜杠（/）。<br>2.在HTML中涉及网络文件地址的要使用斜杠（/），比如</p>
<blockquote>
<p></p><p style="background-image:url(root/img/pic.jpg);"> </p>，<p></p>
</blockquote>
<p>段落的背景图片样式属性的路径必须使用斜杠，反斜杠无效。<br>涉及到本地文件（windows）路径，斜杠反斜杠均可，比如</p>
<blockquote>
<p><img src="C:/Users\Administrator/Desktop\1.png"></p>
</blockquote>
<hr>
<h6 id="2017-2-11-23-37第一次修改"><a href="#2017-2-11-23-37第一次修改" class="headerlink" title="2017.2.11 23:37第一次修改"></a>2017.2.11 23:37第一次修改</h6>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;【笔记】斜杠-forward-salash-与反斜杠-back-salash-在路径应用中的区别&quot;&gt;&lt;a href=&quot;#【笔记】斜杠-forward-salash-与反斜杠-back-salash-在路径应用中的区别&quot; class=&quot;headerlink&quot; tit
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>C++指针辨析</title>
    <link href="https://jqs1970291214.github.io/MyBlog/2017/10/26/C-%E6%8C%87%E9%92%88%E8%BE%A8%E6%9E%90/"/>
    <id>https://jqs1970291214.github.io/MyBlog/2017/10/26/C-指针辨析/</id>
    <published>2017-10-26T15:49:40.000Z</published>
    <updated>2017-10-26T15:59:08.691Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a>
<h1 id="C-指针辨析"><a href="#C-指针辨析" class="headerlink" title="C++指针辨析"></a>C++指针辨析</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">   </div><div class="line"></div><div class="line">    int a1[2];</div><div class="line">    int a2[2];</div><div class="line">    int a3[2];</div><div class="line">    </div><div class="line">    int *p;</div><div class="line">    p=&amp;a1[0];      //a[1]与*(p+1)等价。</div><div class="line">    </div><div class="line">    //pp1是一个指向int [2]的指针，即pp1的类型和&amp;a1是一样的。 a指向的内存长度固定。</div><div class="line">    int pp1[2][2]=&#123;&#123;1,2&#125;,&#123;1,2&#125;&#125;;</div><div class="line">     //pp2是一个指向int *的指针，即pp2的类型和&amp;pp1是一样的。pp指向的内存长度不固定。                </div><div class="line">    int *pp2[3]=&#123;a1,a2,a3&#125;;</div><div class="line">     //pp3是一个指向int [2]的指针，即pp2的类型和&amp;a1是一样的；</div><div class="line">    int (*pp3)[2]=&amp;a1;</div><div class="line">     //pp4是一个指向int *的指针，即pp4的类型和&amp;pp1是一样的；       </div><div class="line">    int **pp4;</div><div class="line">              </div><div class="line">     //可以，类型匹配。         </div><div class="line">    pp1=pp3;</div><div class="line">    pp2=pp4;</div><div class="line">    </div><div class="line">    //不可以。编译错误，无法从int (*)[2]转换为int **！               </div><div class="line">    pp1=pp4;</div><div class="line">    pp2=pp3;</div><div class="line"></div><div class="line">    int (*ps)[2]=&amp;a3;</div><div class="line">    a3[1]=10; </div><div class="line">    cout&lt;&lt;ps[0][1];</div><div class="line">    cout&lt;&lt;*(*ps+1);</div><div class="line">    //*(*ps+1)=ps[0][1]=*(*(ps+0)+1)=a3[1];</div><div class="line">   </div><div class="line"></div><div class="line"></div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<hr>
<h6 id="第一次修改：2016-12-31-0-04"><a href="#第一次修改：2016-12-31-0-04" class="headerlink" title="第一次修改：2016-12-31 0:04"></a>第一次修改：2016-12-31 0:04</h6><h6 id="第二次修改：2017-1-4-22-07"><a href="#第二次修改：2017-1-4-22-07" class="headerlink" title="第二次修改：2017/1/4 22:07"></a>第二次修改：2017/1/4 22:07</h6>]]></content>
    
    <summary type="html">
    
      &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;C-指针辨析&quot;&gt;&lt;a href=&quot;#C-指针辨析&quot; class=&quot;headerlink&quot; title=&quot;C++指针辨析&quot;&gt;&lt;/a&gt;C++指针辨析&lt;/h1&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;tabl
    
    </summary>
    
    
      <category term="C++" scheme="https://jqs1970291214.github.io/MyBlog/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>【笔记】equals方法重写、相等性测试和继承</title>
    <link href="https://jqs1970291214.github.io/MyBlog/2017/10/26/%E3%80%90%E7%AC%94%E8%AE%B0%E3%80%91equals%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E3%80%81%E7%9B%B8%E7%AD%89%E6%80%A7%E6%B5%8B%E8%AF%95%E5%92%8C%E7%BB%A7%E6%89%BF/"/>
    <id>https://jqs1970291214.github.io/MyBlog/2017/10/26/【笔记】equals方法重写、相等性测试和继承/</id>
    <published>2017-10-26T15:05:44.000Z</published>
    <updated>2017-10-26T15:59:38.957Z</updated>
    
    <content type="html"><![CDATA[<h1 id="【笔记】equals方法重写、相等性测试和继承"><a href="#【笔记】equals方法重写、相等性测试和继承" class="headerlink" title="【笔记】equals方法重写、相等性测试和继承"></a>【笔记】equals方法重写、相等性测试和继承</h1><h3 id="一、equals方法重写"><a href="#一、equals方法重写" class="headerlink" title="一、equals方法重写"></a>一、equals方法重写</h3><p>Object类中的equals方法用于检测两个对象是否相等，默认操作为检测两个对象是否具有相同的引用。在Object的子类中一般覆盖equals方法（比如String类），多用于检测两个对象的状态是否相等。<br>重写equals方法，一般采取以下步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public booleanequals(Object other)&#123;</div><div class="line">    //如果两个对象具有相同的引用则返回true，这是一条优化</div><div class="line">    if (this==other) return true;</div><div class="line">    //如果other为null，返回false</div><div class="line">    if (other==null) return false;</div><div class="line">    //如果两个对象不属于同一个类，返回false</div><div class="line">    if (getClass()!=other.getClass()) return false;</div><div class="line">    //现在可以确定两个对象属于同一个类，进行类型转换，假设this属于Person类</div><div class="line">    Person oth=(Person)other;</div><div class="line">    //依次判断实例域是否相等</div><div class="line">    return field1.equals(oth.field1)&amp;&amp;(field2==oth.field2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在覆盖equals方法时，必须使方法名和形参列表和父类一致，由方法名和参数列表组成的方法签名在方法重载起到关键作用，意味着以下写法是不允许的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">public boolean equals(Object oth)&#123;&#125;</div><div class="line">public int equals(Object oth)&#123;&#125;</div></pre></td></tr></table></figure>
<p>我们可以使用@Override来标记被重写的方法，如果方法没有被成功重写，则会给出错误报告，这是一个有效避免错误的小技巧。<br>在判断实例域时，当实例域为对象时应该使用Objects.equals方法，以避免空指针异常，比如上面代码最后一行应改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">return Objects.equals(field1,field2)&amp;&amp;(field2==oth.field2);</div></pre></td></tr></table></figure>
<p>使用该方法需要导入java.util.Objects,如果两个参数都为null，返回true；如果仅有一个为null，返回false，否则调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">para1.equals(para2);</div></pre></td></tr></table></figure>
<p>该方法源码实现摘录如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public static boolean equals(Object a,Object b)&#123;</div><div class="line"></div><div class="line">    return (a == b) || (a != null &amp;&amp; a.equal=s(b)); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="二、相等测试和继承"><a href="#二、相等测试和继承" class="headerlink" title="二、相等测试和继承"></a>二、相等测试和继承</h3><p>如果两个参数不属于一个类，问题就会变得复杂。很多人单纯使用instanceof进行测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if(!(otherinstanceof thisObj)) return false;</div></pre></td></tr></table></figure></p>
<p>不过这么做并没有解决other是thisObj子类的对象的问题，而且违反了equals方法的对称性，Java语言规范要求equals方法的对称性：当且仅当x.equals(y);返回true，y.equals(x);也应该返回true。如果son和父类father共同的域相等且子类中重写了equals方法，按照（一）中的方法，faher.equals(son)会返回true，而son.equals(father)则会返回false，这显然是不合适的。<br>为了改进这个问题，写出更完美的equals方法，可以进行以下判断：</p>
<ul>
<li>如果相等的概念由父类决定，可以使用instanceof进行检测，这样还有利于检测由父类派生出的多个子类的对象之间的相等性。</li>
<li>如果相等的概念由子类决定，equals方法的对称性强制使用getClass()进行检测。</li>
</ul>
<p>在对代码进行修改时，如果相等的概念由子类决定则（一）中代码保持不变。如果相等的概念由父类决定，那么（一）中在判断完other不为null后的第三步改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if(!(otherinstanceof Person)) return false;</div></pre></td></tr></table></figure></p>
<hr>
<p>2017.7.31 18:00第一次编辑</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;【笔记】equals方法重写、相等性测试和继承&quot;&gt;&lt;a href=&quot;#【笔记】equals方法重写、相等性测试和继承&quot; class=&quot;headerlink&quot; title=&quot;【笔记】equals方法重写、相等性测试和继承&quot;&gt;&lt;/a&gt;【笔记】equals方法重写、相等
    
    </summary>
    
    
      <category term="Java" scheme="https://jqs1970291214.github.io/MyBlog/tags/Java/"/>
    
  </entry>
  
</feed>
